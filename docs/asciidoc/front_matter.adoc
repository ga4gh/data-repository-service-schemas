== Introduction

The Data Repository Service (DRS) API provides a generic interface to data repositories so data consumers, including workflow systems, can access data objects in a single, standard way regardless of where they are stored and how they are managed. The primary functionality of DRS is to map a logical ID to a means for physically retrieving the data represented by the ID. The sections below describe the characteristics of those IDs, the types of data supported, how they can be pointed to using URIs, and how clients can use these URIs to ultimately make successful DRS API requests. This document describes the DRS API in detail and provides information on the specific endpoints, request formats, and responses.  This specification is intended for developers of DRS-compatible services and of clients that will call these DRS services.

== DRS API Principles

=== DRS IDs

Each implementation of DRS can choose its own id scheme, as long as it follows these guidelines:

* DRS IDs are strings made up of uppercase and lowercase letters, decimal digits, hypen, period, underscore and tilde [A-Za-z0-9.-_~]. See https://tools.ietf.org/html/rfc3986#section-2.3[RFC 3986 § 2.3].
* DRS IDs can contain other characters, but they MUST be encoded into valid DRS IDs whenever exposed by the API.  This is because non-encoded IDs may interfere with the interpretation of the `objects/{id}/access` endpoint.  To overcome this limitation use percent-encoding of the ID, see https://tools.ietf.org/html/rfc3986#section-2.4[RFC 3986 § 2.4]
* One DRS ID MUST always return the same object data (or, in the case of a collection, the same set of objects). This constraint aids with reproducibility.
* DRS implementations MAY have more than one ID that maps to the same object.
* DRS version 1.x does NOT support semantics around multiple versions of an object. (For example, there’s no notion of “get latest version” or “list all versions”.) Individual implementation MAY choose an ID scheme that includes version hints.


=== DRS URIs

For convenience, including when passing content references to a https://github.com/ga4gh/workflow-execution-service-schemas[WES server], we define a https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Generic_syntax[URI scheme] for DRS-accessible content. See https://tools.ietf.org/html/rfc3986#section-3.1[RFC 3986 § 3.1]. _We feel it is important to introduce a DRS scheme for URIs since it signals to systems consuming these URIs that the response they will ultimately receive, once transforming the URI to a fetchable URL, will be a DRS JSON._ If we had gone with a https://en.wikipedia.org/wiki/CURIE[Compact URI (CURIE)] we felt that this would have been more difficult for systems consuming DRS objects to understand and differentiate them given the ubiquitous use of CURIEs in the research community and the fact that CURIEs can point to a wide variety of entities (HTML documents, PDFs, identities in data models, etc).

There are two styles of DRS URIs: Compact Identifier-based and Hostname-based, both use the `drs://` URI scheme.

==== Compact Identifier-based DRS URIs

Compact identifiers refer to locally-unique persistent identifiers that have been namespaced to provide global uniqueness. See https://www.biorxiv.org/content/10.1101/101279v3["Uniform resolution of compact identifiers for biomedical data"] for an excellent introduction to this topic.  We support the use of compact identifiers in DRS URIs since many resources in the research community issue these identifiers in a variety of formats.  We leverage the resolver registry services of https://identifiers.org/[identifiers.org] or https://n2t.net/[n2t.net (Name-To-Thing)] to support any registered form of compact identifiers (Arks, DOIs, Data GUIDs, etc), allowing for the resolution of DRS objects without needing to use a hostname in the URI.

TIP: Much more information is provided in the <<_appendix_compact_identifiers>>.

.Note: DRS Service Implementers Prefix Registration
****
If your DRS implementation will issue IDs based on compact identifiers, and pass around DRS URIs using these compact identifiers, you *must* register your prefix (which consists of `[provider_code/]namespace`) on identifiers.org/n2t.net. If you don't, DRS clients will not know how to resolve your compact identifiers and, ultimately, generate a valid DRS URL that clients can access.
****

Translating the identifiers.org/n2t.net CURIE format to a DRS compact identifier-based URI we get the following form. Together provider code and the namespace are referred to as the _prefix_. The provider code is optional and is used by identifiers.org/n2t.net for compact identifier resolver mirrors:

    drs://[provider_code/]namespace:accession

.Note: DRS Client Compact Identifier-Based URI Resolution Process
****
A DRS client identifies the a DRS URI compact identifier components using the first occurance of "/" (optional) and ":" characters. These are not allowed inside the provider_code (optional) or the namespace. The ":" character is also not allowed in a Hostname-based DRS URI, providing a convenient mechanism to differentiate them. Once the provider_code (optional) and namespace are extracted from a DRS URI, a client can use services on identifiers.org to identify available resolvers. For example, for a Data GUID namespace of "dg" the following GET request will return information about the namespace:

    GET https://registry.api.identifiers.org/restApi/namespaces/search/findByPrefix?prefix=dg

This information then points to resolvers for the "dg" namespace (assuming the namespace ID identified by the response to the above GET request for Data GUIDs is 1234):

    GET https://registry.api.identifiers.org/restApi/resources/search/findAllByNamespaceId?id=1234

This returns enough information to, ultimately, identify one or more resolvers and each have a URL prefix that, for DRS-supporting systems, tells how to make a successful DRS GET request.

Walking through a hypothetical Data GUID example compact identifier DRS URI's resolution:

    drs://dg:4503/00e6cfa9-a183-42f6-bb44-b70347106bbe

Looking up the resolver on identifiers.org would tell you the URL pattern to get a DRS response would be:

    https://dataguids.org/ga4gh/drs/v1/objects/dg.{$id}

And that can then be translated to the following using the accession parsed from the compact identifier that has been percent-encoded since DRS IDs must only use non-reserved URI characters:

    GET https://dataguids.org/ga4gh/drs/v1/objects/dg.4503%2F00e6cfa9-a183-42f6-bb44-b70347106bbe

_IDs in DRS hostname-based URIs/URLs are always percent-encoded to eliminate ambiguity even though the DRS compact identifier-based URIs do not percent encode accessions.  This was done in order to 1) follow the CURIE conventions of identifiers.org/n2t.net for compact identifier-based DRS URIs and 2) to aid in readability for users who understand they are working with compact identifiers._ **The general rule of thumb, when using an compact identifier accession as a DRS ID make sure to percent-encode it.**

Please keep in mind identifiers.org/n2t.net does not support directly resolving percent-encoded accessions. _So we recommend the approach above for DRS clients to look up resolvers on these registries and then make a valid DRS GET request directly, using the percent-encoded accession as the DRS ID in the GET request._  This approach is also useful for caching resolvers and their URL patterns for performance reasons since this information is unlikely to change frequently.
****

==== Hostname-based DRS URIs

Hostname-based DRS URIs are simpler than compact identifier-based URIs.  They contain the DRS server name and the DRS ID only and can be converted directly into a fetchable URL based on a simple rule.  They take the form:

    drs://<hostname>/<id>

.Note: DRS Client Hostname-Based URI Resolution Process
****
Strings of the form `drs://<hostname>/<id>` mean _“you can fetch the content with DRS id `<id>` from the DRS server at `<hostname>` "_.  For example, if a WES server was asked to process:

    drs://drs.example.org/314159

It would know that it could issue a GET request to:

    https://drs.example.org/ga4gh/drs/v1/objects/314159

to learn how to fetch that data object via one of the available access approaches.

The protocol is always https and the port is always the standard 443 SSL port.  It would be invalid to include, for example, a different port in the DRS hostname-based URI.

In hostname-based DRS URIs, the ID is always percent-encoded to ensure special characters do not interfere with subsequent DRS endpoint calls.  As such, ":" is not allowed in the URI and is a convenient way of differentiating from a compact identifier-based DRS URI.  Also, if a given DRS service implementation uses compact identifier accessions as their DRS IDs, they must be percent encoded before using them as DRS IDs in hostname-based DRS URIs.
****

Hostname-based DRS URIs are less resistant to future project/domain name changes than compact identifiers.  But they do provide a more direct way of pointing to a DRS object which can have benefits.  The fact that they can be resolved using a simple rule means a DRS client can skip the extra overhead of a prefix lookup as is done for compact identifier-based URIs.  This can translate to possibly greater performance and/or security since the DRS server hostname is explicitly specified and this avoids the lookup of a resolver through a separate service (identifiers.org/n2t.net).

TIP: Information on how hostname-based DRS URI resolution to URLs will work in the future is provided in the <<_appendix_service_registry_and_service_info>>. 

=== DRS Datatypes

DRS v1 supports two types of content:

* a _blob_ is like a file -- it's a single blob of bytes, represented by a `DrsObject` without a `contents` array
* a _bundle_ is like a folder -- it's a collection of other DRS content (either blobs or bundles), represented by a `DrsObject` with a `contents` array

=== Read-only

DRS v1 is a read-only API. We expect that each implementation will define its own mechanisms and interfaces (graphical and/or programmatic) for adding and updating data.

=== Standards

The DRS API specification is written in OpenAPI and embodies a RESTful service philosophy.  It uses JSON in requests and responses and standard HTTPS on port 443 for information transport.

== Authorization & Authentication

=== Making DRS Requests

The DRS implementation is responsible for defining and enforcing an authorization policy that determines which users are allowed to make which requests. GA4GH recommends that DRS implementations use an OAuth 2.0 https://oauth.net/2/bearer-tokens/[bearer token], although they can choose other mechanisms if appropriate.

=== Fetching DRS Objects

The DRS API allows implementers to support a variety of different content access policies, depending on what `AccessMethod` s they return:

* public content:
** server provides an `access_url` with a `url` and no `headers`
** caller fetches the object bytes without providing any auth info
* private content that requires the caller to have out-of-band auth knowledge (e.g. service account credentials):
** server provides an `access_url` with a `url` and no `headers`
** caller fetches the object bytes, passing the auth info they obtained out-of-band
* private content that requires the caller to pass an Authorization token:
** server provides an `access_url` with a `url` and `headers`
** caller fetches the object bytes, passing auth info via the specified header(s)
* private content that uses an expensive-to-generate auth mechanism (e.g. a signed URL):
** server provides an `access_id`
** caller passes the `access_id` to the `/access` endpoint
** server provides an `access_url` with the generated mechanism (e.g. a signed URL in the `url` field)
** caller fetches the object bytes from the `url` (passing auth info from the specified headers, if any)

DRS implementers should ensure their solutions restrict access to targets as much as possible, detect attempts to exploit through log monitoring, and they are prepared to take action if an exploit in their DRS implementation is detected.
