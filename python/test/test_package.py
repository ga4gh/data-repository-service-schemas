# -*- coding: utf-8 -*-
import os.path
import unittest

import openapi_spec_validator
import requests
import swagger_spec_validator
import yaml


class TestPackage(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cwd = os.path.dirname(os.path.realpath(__file__))
        spec_dir = os.path.join(cwd, '../../openapi')
        cls.swagger_path = os.path.join(spec_dir, 'data_repository_service.swagger.yaml')
        cls.smartapi_path = os.path.join(spec_dir, 'data_repository_service.smartapi.yaml')
        cls.openapi_path = os.path.join(spec_dir, 'data_repository_service.openapi.yaml')

        # The :func:`unittest.skipUnless` calls depend on class variables,
        # which means that we can't decorate the test cases conventionally
        # and have to do so after the class variables we need are instantiated.
        openapi_dec = unittest.skipUnless(os.path.exists(cls.openapi_path), "Generated schema not found.")
        cls.test_openapi_schema_validity = openapi_dec(cls.test_openapi_schema_validity)
        smartapi_dec = unittest.skipUnless(os.path.exists(cls.smartapi_path), "Generated schema not found.")
        cls.test_smartapi_schema_validity = smartapi_dec(cls.test_smartapi_schema_validity)

    def test_version_consensus(self):
        from ga4gh.drs import __version__
        with open(self.swagger_path, 'r') as f:
            spec_version = yaml.safe_load(f)['info']['version']
        assert __version__ == spec_version

    def test_swagger_schema_validity(self):
        """Validate the Swagger schema using swagger_spec_validator."""
        # We always expect the Swagger schema to exist since it's the
        # reference implementation from which the OpenAPI (3.0) and SmartAPI
        # schemas are generated, so we won't include a silent skip condition
        # like we would for :meth:`test_openapi_schema_validity` or
        # :meth:`test_smartapi_schema_validity`.
        path = os.path.abspath(self.swagger_path)
        swagger_spec_validator.validate_spec_url('file://' + path)

    def test_openapi_schema_validity(self):
        """
        Validate the generated OpenAPI schema. Will be skipped if the
        generated schema file is not present.
        """
        # p1c2u/openapi-spec-validator supports validation of both Swagger
        # and OpenAPI schemas, but since Yelp/swagger_spec_validator is
        # installed with the other dependencies anyway, it's easier to just
        # leave it in place.
        path = os.path.abspath(self.openapi_path)
        openapi_spec_validator.validate_v3_spec_url('file://' + path)

    def test_smartapi_schema_validity(self):
        """
        Validates the generated SmartAPI schema by temporarily uploading
        it to a third-party pastebin then using the SmartAPI API to
        validate the schema. Will be skipped if the generated schema
        file is not present.
        """
        schema = {'file': open(self.smartapi_path, 'rb')}
        post = requests.post('https://file.io/', files=schema)
        self.assertTrue(post.json()['success'], post.json())
        validate = requests.get('https://smart-api.info/api/validate?url=' + post.json()['link'])
        # A couple notes on the /validate endpoint, since it appears to be
        # mostly undocumented:
        # * The endpoint will always return HTTP 200 regardless of whether
        #   or not the schema is valid
        # * If the schema is invalid, the endpoint will return something
        #   like {'success': false}
        # * If the schema is valid, the endpoint will return something
        #   like {'valid': true}
        self.assertTrue(validate.json()['valid'], validate.json())

    def test_chalice_schema_generation(self):
        """
        Validate that the schema generated by :func:`ga4gh.drs.schema.from_chalice_routes`
        is valid.
        """
        from ga4gh.drs.schema import from_chalice_routes
        routes = {
            # Test a path that does not exist in the schema
            '/PathThatDoesNotExist': {'GET': None},
            # Test a valid path with a nonexistent method
            '/ga4gh/drs/v1/bundles': {'MethodThatDoesNotExist': None},
            # Test a path with a different case than what is defined in the schema
            '/GA4GH/DRS/V1/BUNDLES/{bundle_id}': {'GET': None},
            # Test multiple methods
            '/ga4gh/drs/v1/objects/{object_id}': {'GET': None,
                                                           'PUT': None}
        }
        schema = from_chalice_routes(routes, base_path='/ga4gh/drs/v1')
        paths = schema['paths']

        self.assertNotIn('/PathThatDoesNotExist', paths.keys())
        # Test that base path is correctly stripped
        self.assertNotIn('/ga4gh/drs/v1/bundles', paths.keys())
        self.assertIn('/bundles/{bundle_id}', paths.keys())
        self.assertNotIn('MethodThatDoesNotExist', paths['/bundles'].keys())
        self.assertIn('get', paths['/objects/{object_id}'].keys())
        self.assertIn('put', paths['/objects/{object_id}'].keys())
        self.assertNotIn('/objects', paths.keys())
        # Make sure that the schema is intact
        self.assertIn('200', paths['/objects/{object_id}']['get']['responses'].keys())
